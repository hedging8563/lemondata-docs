---
title: "✨ インテリジェント・キャッシング"
description: "コンテキストを考慮したセマンティック・キャッシングにより、コストとレイテンシを削減します"
---

## 概要

LemonDataは、APIコストとレスポンスのレイテンシを大幅に削減できるインテリジェント・キャッシング・システムを提供します。当社のキャッシングは単なるリクエストのマッチングにとどまらず、プロンプトの**セマンティックな意味（意味論的な意味）**を理解します。

<CardGroup cols={2}>
  <Card title="コスト削減" icon="piggy-bank">
    キャッシュヒット時は、通常のコストの数分の一で請求されます。
  </Card>
  <Card title="レスポンスの高速化" icon="bolt">
    キャッシュされたレスポンスは即座に返され、モデルの推論は不要です。
  </Card>
  <Card title="コンテキスト対応" icon="brain">
    セマンティック・マッチングにより、言い回しが異なる場合でも類似のリクエストを特定します。
  </Card>
  <Card title="プライバシー・コントロール" icon="shield">
    何をキャッシュし、共有するかを完全に制御できます。
  </Card>
</CardGroup>

## 仕組み

LemonDataは2層のキャッシング・システムを使用しています：

### レイヤー1：レスポンス・キャッシュ（完全一致）

決定論的なリクエスト（`temperature=0`）の場合、正確なレスポンスをキャッシュします：

- **一致条件**：同一のモデル、メッセージ、およびパラメータ
- **速度**：即時（マイクロ秒単位）
- **最適な用途**：繰り返される同一のクエリ

### レイヤー2：セマンティック・キャッシュ（類似性一致）

すべてのリクエストに対して、2段階のマッチング・アルゴリズムを使用してセマンティックな類似性もチェックします：

- **ステージ1（クエリのみ）**：ユーザー・クエリで95%以上の類似性
- **ステージ2（フル・コンテキスト）**：会話のコンテキストを含めて85%以上の類似性
- **最適な用途**：FAQ形式のクエリ、よくある質問

```
User A: "What is the capital of France?"
User B: "Tell me the capital city of France"
→ 同じキャッシュレスポンス（高いセマンティック類似性）
```

## キャッシュ・ヘッダー

### リクエスト・ヘッダー

リクエストごとにキャッシングの動作を制御します：

```bash
# キャッシュルックアップをスキップし、常にモデルを呼び出す
curl https://api.lemondata.cc/v1/chat/completions \
  -H "Authorization: Bearer sk-your-key" \
  -H "Cache-Control: no-cache" \
  -d '{"model": "gpt-4o", "messages": [...]}'
```

| ヘッダー | 値 | 効果 |
|--------|-------|--------|
| `Cache-Control: no-cache` | - | キャッシュをスキップし、新しいレスポンスを取得 |
| `Cache-Control: no-store` | - | このレスポンスをキャッシュしない |

### レスポンス・ヘッダー

すべてのレスポンスにキャッシュ・ステータスが含まれます：

```
X-Cache: HIT           # キャッシュから提供されたレスポンス
X-Cache: MISS          # モデルからの新しいレスポンス
X-Cache-Entry-Id: abc  # キャッシュ・エントリID（フィードバック用）
```

## キャッシュ・ステータスの確認

```python
from openai import OpenAI

client = OpenAI(
    api_key="sk-your-key",
    base_url="https://api.lemondata.cc/v1"
)

response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "What is 2+2?"}]
)

# レスポンス・ヘッダーからキャッシュ・ステータスを確認する
# （生のHTTPレスポンスで利用可能）
print(f"Cache: {response._raw_response.headers.get('X-Cache')}")
```

## キャッシュの請求

キャッシュヒットは、新しいリクエストよりも大幅に安価です：

| タイプ | コスト |
|------|------|
| キャッシュ HIT | **80% オフ** |
| キャッシュ MISS | 定価 |

正確な割引額は、ダッシュボードの使用状況ログに表示されます。

## プライバシー・コントロール

### APIキー・レベル

ダッシュボードで各APIキーのキャッシング動作を設定します：

| モード | 説明 |
|------|-------------|
| **デフォルト** | キャッシュ有効。類似のリクエストと共有される可能性があります |
| **共有なし** | キャッシュ有効。ただし、レスポンスはお客様のアカウント専用となります |
| **無効** | キャッシングを一切行わない |

### リクエスト・レベル

リクエストごとに上書きします：

```bash
# このリクエストのキャッシングを無効にする
curl https://api.lemondata.cc/v1/chat/completions \
  -H "Cache-Control: no-store" \
  -d '...'
```

## キャッシュ・フィードバック

誤ったキャッシュ・レスポンスを受け取った場合は、報告することができます：

```bash
curl -X POST https://api.lemondata.cc/v1/cache/feedback \
  -H "Authorization: Bearer sk-your-key" \
  -H "Content-Type: application/json" \
  -d '{
    "cache_entry_id": "abc123",
    "feedback_type": "wrong_answer",
    "description": "Response was outdated"
  }'
```

**フィードバックの種類：**
- `wrong_answer` - 事実と異なる
- `outdated` - 情報が古い
- `irrelevant` - 質問と一致しない
- `other` - その他の問題

キャッシュ・エントリが十分な負のフィードバックを受けると、自動的に無効化されます。

## ベストプラクティス

<AccordionGroup>
  <Accordion title="キャッシュ可能なクエリには temperature=0 を使用する">
    決定論的な設定により、キャッシュヒット率が最大化されます。
  </Accordion>

  <Accordion title="プロンプトの形式を標準化する">
    一貫したフォーマットにより、セマンティック・マッチングが向上します。
  </Accordion>

  <Accordion title="時間に敏感なクエリには no-cache を使用する">
    時事問題やリアルタイム・データはキャッシュをスキップする必要があります。
  </Accordion>

  <Accordion title="キャッシュヒット率を監視する">
    ダッシュボードでキャッシュの統計と節約額を確認してください。
  </Accordion>
</AccordionGroup>

## キャッシュすべきでない場合

以下の場合、キャッシングを無効にしてください：

- **リアルタイム情報**：株価、天気、ニュース
- **パーソナライズされたコンテンツ**：ユーザー固有の推奨事項
- **クリエイティブなタスク**：多様性が求められる場合
- **機密データ**：機密情報

```python
# 時間に敏感なクエリの場合
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "What's the current stock price of AAPL?"}],
    extra_headers={"Cache-Control": "no-cache"}
)
```