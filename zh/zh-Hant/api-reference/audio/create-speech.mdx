**Beginning the translation process**

The frontmatter and the first sections are translated. I am following all the specified rules. Code blocks, URLs and API endpoints are untouched. Common technical terms are kept in English as requested. Table headers and content have been carefully translated. I've preserved markdown syntax and structure.


---
title: "错误处理"
description: "优雅地处理 API 错误"
---

## 错误响应格式

所有错误都返回一致的 JSON 格式：

```json
{
  "error": {
    "message": "Human-readable error description",
    "type": "error_type",
    "code": "error_code",
    "param": "parameter_name"  // Optional, for validation errors
  }
}
```

## HTTP 状态码

| 代码 | 描述 |
|------|-------------|
| 400 | Bad Request - 参数无效 |
| 401 | Unauthorized - API 密钥无效或缺失 |
| 402 | Payment Required - 余额不足 |
| 403 | Forbidden - 访问被拒绝或模型未授权 |
| 404 | Not Found - 未找到模型或资源 |
| 413 | Payload Too Large - 输入或文件大小超限 |
| 429 | Too Many Requests - 已超过速率限制 |
| 500 | Internal Server Error - 内部服务器错误 |
| 502 | Bad Gateway - 上游供应商错误 |
| 503 | Service Unavailable - 所有渠道均失败 |
| 504 | Gateway Timeout - 请求超时 |

## 错误类型

### 身份验证错误 (401)

| 类型 | 代码 | 描述 |
|------|------|-------------|
| `invalid_api_key` | `invalid_api_key` | API 密钥缺失或无效 |
| `expired_api_key` | `expired_api_key` | API 密钥已被撤销 |

```python
from openai import OpenAI, AuthenticationError

try:
    response = client.chat.completions.create(...)
except AuthenticationError as e:
    print(f"Authentication failed: {e.message}")
```

### 支付错误 (402)

| 类型 | 代码 | 描述 |
|------|------|-------------|
| `insufficient_quota` | `insufficient_quota` | 账户余额过低 |
| `quota_exceeded` | `quota_exceeded` | 已达到 API 密钥使用限制 |

```python
from openai import OpenAI, APIStatusError

try:
    response = client.chat.completions.create(...)
except APIStatusError as e:
    if e.status_code == 402:
        print("Please top up your account balance")
```

### 访问错误 (403)

| 类型 | 代码 | 描述 |
|------|------|-------------|
| `access_denied` | `access_denied` | 资源访问被拒绝 |
| `access_denied` | `model_not_allowed` | 此 API 密钥不允许使用该模型 |

```json
{
  "error": {
    "message": "You don't have permission to access this model",
    "type": "access_denied",
    "code": "model_not_allowed"
  }
}
```

### 校验错误 (400)

| 类型 | 描述 |
|------|-------------|
| `invalid_request_error` | 请求参数无效 |
| `context_length_exceeded` | 输入长度超过模型限制 |
| `model_not_found` | 请求的模型不存在 |

```json
{
  "error": {
    "message": "model: 'invalid-model' is not a valid model",
    "type": "model_not_found",
    "param": "model"
  }
}
```

### 速率限制错误 (429)

当您超过速率限制时：

```json
{
  "error": {
    "message": "Rate limit exceeded. Please retry later.",
    "type": "rate_limit_error",
    "code": "rate_limit_exceeded"
  }
}
```

**包含的响应头：**

```
Retry-After: 60
```

`Retry-After` 响应头指示在重试前需要等待的秒数。

### 有效负载过大 (413)

当输入或文件大小超过限制时：

```json
{
  "error": {
    "message": "Input size exceeds maximum allowed",
    "type": "invalid_request_error",
    "code": "payload_too_large"
  }
}
```

常见原因：
- 图片文件过大（最大 20MB）
- 音频文件过大（最大 25MB）
- 输入文本超过模型上下文长度

### 上游错误 (502, 503)

| 类型 | 描述 |
|------|-------------|
| `upstream_error` | 供应商返回错误 |
| `all_channels_failed` | 没有可用的供应商 |
| `timeout_error` | 请求超时 |

## 在 Python 中处理错误

```python
from openai import OpenAI, APIError, RateLimitError, APIConnectionError

client = OpenAI(
    api_key="sk-your-api-key",
    base_url="https://api.lemondata.cc/v1"
)

def chat_with_retry(messages, max_retries=3):
    for attempt in range(max_retries):
        try:
            return client.chat.completions.create(
                model="gpt-4o",
                messages=messages
            )
        except RateLimitError as e:
            if attempt < max_retries - 1:
                import time
                time.sleep(2 ** attempt)  # Exponential backoff
                continue
            raise
        except APIConnectionError as e:
            print(f"Connection error: {e}")
            raise
        except APIError as e:
            print(f"API error: {e.status_code} - {e.message}")
            raise
```

## 在 JavaScript 中处理错误

```javascript
import OpenAI from 'openai';

const client = new OpenAI({
  apiKey: 'sk-your-api-key',
  baseURL: 'https://api.lemondata.cc/v1'
});

async function chatWithRetry(messages, maxRetries = 3) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await client.chat.completions.create({
        model: 'gpt-4o',
        messages
      });
    } catch (error) {
      if (error instanceof OpenAI.RateLimitError) {
        if (attempt < maxRetries - 1) {
          await new Promise(r => setTimeout(r, 2 ** attempt * 1000));
          continue;
        }
      }
      throw error;
    }
  }
}
```

## 最佳实践

<AccordionGroup>
  <Accordion title="实现指数退避">
    当受到速率限制时，在重试之间逐渐增加等待时间：
    ```python
    wait_time = 2 ** attempt  # 1s, 2s, 4s, 8s...
    ```
  </Accordion>

  <Accordion title="设置超时">
    始终设置合理的超时时间，以避免请求挂起：
    ```python
    client = OpenAI(timeout=60.0)  # 60 second timeout
    ```
  </Accordion>

  <Accordion title="记录错误日志以便调试">
    记录完整的错误响应（包括请求 ID）以便寻求支持：
    ```python
    except APIError as e:
        logger.error(f"API Error: {e.status_code} - {e.message}")
    ```
  </Accordion>

  <Accordion title="处理特定于模型的错误">
    某些模型有特定要求（例如：最大 token 数、图片格式）。在发起请求前校验输入。
  </Accordion>
</AccordionGroup>