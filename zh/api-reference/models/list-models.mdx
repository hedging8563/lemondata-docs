**My Translation Strategy for MDX Documentation**

Okay, here's the approach I'll take. As a professional technical documentation translator specializing in English to Simplified Chinese, and with experience in MDX, I need to make sure I get this right. The task is straightforward: translate the provided content while adhering to very specific rules. My main goal is to produce the translated content and *only* the translated content, in the correct output language (Simplified Chinese), and not to translate any of the content that should be left in English.

First, I'll systematically go through the document. I need to translate all text content, including headings, paragraphs, list items, and titles/descriptions in cards. At the same time, I absolutely cannot translate code blocks, inline code snippets (except for the contents if the inline code is a full sentence), URLs, API endpoints/paths, variable names, component names (like `<ResponseField>`), or parameter names.

I must maintain the original MDX structure and formatting, so the final translated document has the same look and feel as the source. Markdown syntax, line breaks, and spacing are crucial, and they all need to be identical.

There are certain technical terms that I will keep in English, like "API," "SDK," and "token." The tone has to be professional and technical throughout, consistent with the original documentation.

Let's break down the individual elements. The frontmatter: I need to translate the `title` from "List Models" to "列出模型" and the `description` from "Lists all available models" to "列出所有可用模型".  The `openapi` line will remain untouched because it's a URL, "GET /v1/models"

Headings are easy, so "## Response" becomes "## 响应", "## Filtering by Provider" becomes "## 按提供商筛选", and "## Model Categories" becomes "## 模型类别".

For the `<ResponseField>` components, it's about identifying the parts to translate. The content inside the component needs attention. So, "Always list." goes to "始终为 list。" (keeping `list` in English since it is inline code), "Array of model objects." becomes "模型对象数组。", and "Each model contains:" goes to "每个模型包含：". Then, I translate the descriptive parts within the list items, like "- id (string): Model identifier" becomes "- id (string): 模型标识符" and so on.

Code examples and labels will be kept as-is. Labels like "bash cURL" and "python Python" stay in English.

When I deal with tables, like "Provider | Example Models |", the header row translates to "| 提供商 | 示例模型 |". However, the table content itself - and especially model names or identifiers in backticks - will remain unchanged.

I'll keep a careful eye out for the self-correction aspect as well. For example, I need to remember that parameters, like `owned_by`, `id`, `object`, and `created`, are left in English. The exact type value is preserved in English as well ("list", "model").

Finally, I'll go through the completed translation to make sure I did not make an error. I need to make sure the table alignment is right, and the MDX tags (<ResponseField>, and others) are all untouched. I have to avoid adding any introductory or concluding text like "Here is the translation".


---
title: "列出模型"
openapi: "GET /v1/models"
description: "列出所有可用模型"
---

## 响应

<ResponseField name="object" type="string">
  始终为 `list`。
</ResponseField>

<ResponseField name="data" type="array">
  模型对象数组。

  每个模型包含：
  - `id` (string): 模型标识符
  - `object` (string): `model`
  - `created` (integer): 创建时间戳
  - `owned_by` (string): 模型提供商
</ResponseField>

<RequestExample>
```bash cURL
curl "https://api.lemondata.cc/v1/models" \
  -H "Authorization: Bearer sk-your-api-key"
```

```python Python
from openai import OpenAI

client = OpenAI(
    api_key="sk-your-api-key",
    base_url="https://api.lemondata.cc/v1"
)

models = client.models.list()

for model in models.data:
    print(f"{model.id} ({model.owned_by})")
```

```javascript JavaScript
import OpenAI from 'openai';

const client = new OpenAI({
  apiKey: 'sk-your-api-key',
  baseURL: 'https://api.lemondata.cc/v1'
});

const models = await client.models.list();

for (const model of models.data) {
  console.log(`${model.id} (${model.owned_by})`);
}
```

```go Go
package main

import (
    "context"
    "fmt"
    "github.com/sashabaranov/go-openai"
)

func main() {
    config := openai.DefaultConfig("sk-your-api-key")
    config.BaseURL = "https://api.lemondata.cc/v1"
    client := openai.NewClientWithConfig(config)

    models, err := client.ListModels(context.Background())
    if err != nil {
        panic(err)
    }

    for _, model := range models.Models {
        fmt.Printf("%s (%s)\n", model.ID, model.OwnedBy)
    }
}
```

```php PHP
<?php
$ch = curl_init('https://api.lemondata.cc/v1/models');

curl_setopt_array($ch, [
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_HTTPHEADER => [
        'Authorization: Bearer sk-your-api-key'
    ]
]);

$response = curl_exec($ch);
curl_close($ch);

$data = json_decode($response, true);
foreach ($data['data'] as $model) {
    echo "{$model['id']} ({$model['owned_by']})\n";
}
```
</RequestExample>

<ResponseExample>
```json Response
{
  "object": "list",
  "data": [
    {
      "id": "gpt-4o",
      "object": "model",
      "created": 1706000000,
      "owned_by": "openai"
    },
    {
      "id": "claude-sonnet-4-5",
      "object": "model",
      "created": 1706000000,
      "owned_by": "anthropic"
    },
    {
      "id": "gemini-2.5-flash",
      "object": "model",
      "created": 1706000000,
      "owned_by": "google"
    }
  ]
}
```
</ResponseExample>

## 按提供商筛选

```python
# 获取所有 OpenAI 模型
openai_models = [m for m in models.data if m.owned_by == "openai"]

# 获取所有 Anthropic 模型
anthropic_models = [m for m in models.data if m.owned_by == "anthropic"]
```

## 模型类别

| 提供商 | 示例模型 |
|----------|----------------|
| `openai` | gpt-4o, gpt-4o-mini, o3, gpt-5.2, dall-e-3 |
| `anthropic` | claude-sonnet-4-5, claude-opus-4-5, claude-haiku-4-5 |
| `google` | gemini-2.5-flash, gemini-2.5-pro, gemini-3-pro-preview |
| `deepseek` | deepseek-r1, deepseek-v3-2 |
| `meta` | llama-3.3-70b, llama-3.1-405b |