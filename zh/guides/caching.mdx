**My Translation Approach: A Deep Dive**

Okay, here's how I'm approaching this MDX documentation translation, specifically from English to Simplified Chinese. My focus is on delivering a precise, professional translation that respects both the technical nature of the content and the nuances of the target language.

First, the core principle: translate *everything* that conveys meaning – headings, paragraphs, lists, card titles, descriptions, etc. I'm aiming for clarity and accurate communication of the technical concepts.

However, certain elements are *sacrosanct* and remain untouched. This includes any code blocks, inline code snippets, URLs, API endpoints/paths, variable names, technical identifiers, component names (like `<Card>`), and parameter names. These are integral to the code and technical architecture, and they should remain in their original form.

Crucially, I'm absolutely committed to preserving the original MDX structure and formatting. Markdown syntax should be meticulously maintained, including line breaks and spacing. The structure of the document *must* remain intact.

I'm keeping a close eye on technical terminology. Common terms like "API", "SDK", "token," and so on, will stay in English, as they are often understood in the global technical sphere. However, I need to ensure the use of the term "Prompt" because I see it is used for "提示词", but I must verify its context to be consistent. "HIT" and "MISS" are also technical statuses and must not be translated.

The *tone* is paramount. The translated documentation will maintain a professional and technical voice. I want to sound authoritative and clear, mirroring the original's intent.

My output will be *strictly* the translated content. No extraneous text, explanations, or notes. It's about delivering the finished translation directly.

As I go through this specific document, I'll pay close attention to the following examples:

*   **Frontmatter:** I'll translate the `title` and `description` fields.
*   **Overview and other sections:** Each heading, and the body text, is fair game. I will, of course, translate the `Prompt` as necessary.
*   **CardGroup:** All card titles and descriptions will be translated.
*   **How It Works:** I'll translate all headings and paragraph text, making sure to identify technical terms that should remain in English.
*   **Code blocks and comments:** I will *not* translate any code block comments that explain the code; I will however keep the code as is.
*   **Cache Control:** I will translate the text but keep `cache_control` untranslated.
*   **Response Headers:** I will translate the text and the meaning but keep `X-Cache-Status` untranslated.
*   **Billing:** I'll translate the text and the table headers, while keeping `HIT` and `MISS` untouched.
*   **Privacy Controls:** I will translate the table headers and description, while keeping specific technical settings in English.
*   **Cache Feedback, Best Practices, When NOT to Cache:** I'll translate all relevant text, focusing on technical accuracy.
*   **Self-Correction:** I will pay attention to all technical terms I have decided to keep, or translated.

I am confident in my ability to meet these requirements and deliver a faithful, accurate, and professional Simplified Chinese translation of this documentation.


---
title: "✨ 智能缓存"
description: "通过上下文感知的语义缓存降低成本和延迟"
---

## 概览

LemonData 提供了一个智能缓存系统，可以显著降低您的 API 成本和响应延迟。我们的缓存不仅限于简单的请求匹配 —— 它还能理解 Prompt 的**语义含义**。

<CardGroup cols={2}>
  <Card title="节省成本" icon="piggy-bank">
    缓存命中仅按正常成本的一小部分计费。
  </Card>
  <Card title="更快的响应" icon="bolt">
    缓存的响应会立即返回，无需模型推理。
  </Card>
  <Card title="上下文感知" icon="brain">
    语义匹配即使在措辞不同的情况下也能找到相似的请求。
  </Card>
  <Card title="隐私控制" icon="shield">
    完全控制缓存和共享的内容。
  </Card>
</CardGroup>

## 工作原理

LemonData 使用双层缓存系统：

### 第一层：响应缓存（精确匹配）

对于确定性请求（`temperature=0`），我们会缓存精确的响应：

- **匹配**：相同的 `model`、`messages` 和参数
- **速度**：即时（微秒级）
- **最适用于**：重复的相同查询

### 第二层：语义缓存（相似度匹配）

对于所有请求，我们还会使用两阶段匹配算法检查语义相似度：

- **第一阶段（仅查询）**：用户查询相似度 ≥95%
- **第二阶段（完整上下文）**：包含对话上下文的相似度 ≥85%
- **最适用于**：常见问题解答（FAQ）类查询、常见问题

```
用户 A："法国的首都是哪里？"
用户 B："告诉我法国的首都城市"
→ 相同的缓存响应（高语义相似度）
```

## 缓存控制

### 请求级控制

使用请求体中的 `cache_control` 参数控制每个请求的缓存行为：

```bash
# 跳过缓存查找，始终调用模型
curl https://api.lemondata.cc/v1/chat/completions \
  -H "Authorization: Bearer sk-your-key" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "gpt-4o",
    "messages": [{"role": "user", "content": "Hello"}],
    "cache_control": {"type": "no_cache"}
  }'
```

| 类型 | 效果 |
|------|--------|
| `no_cache` | 跳过缓存查找，始终获取新鲜响应 |
| `no_store` | 不将此响应存储在缓存中 |
| `response_only` | 仅使用精确匹配缓存（跳过语义匹配） |
| `semantic_only` | 仅使用语义缓存（跳过精确匹配） |

### 响应头

每个响应都包含缓存状态：

```
X-Cache-Status: HIT    # 响应来自缓存
X-Cache-Status: MISS   # 来自模型的新鲜响应
```

## 检查缓存状态

```python
from openai import OpenAI

client = OpenAI(
    api_key="sk-your-key",
    base_url="https://api.lemondata.cc/v1"
)

response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "What is 2+2?"}]
)

# 从响应头检查缓存状态
# （在原始 HTTP 响应中可用）
print(f"Cache: {response._raw_response.headers.get('X-Cache-Status')}")
```

## 缓存计费

缓存命中比新鲜请求便宜得多：

| 类型 | 成本 |
|------|------|
| 缓存 HIT | **2 折（优惠 80%）** |
| 缓存 MISS | 全价 |

具体的折扣显示在您的控制面板使用日志中。

## 隐私控制

### 组织 / 用户级别

在您的控制面板设置中配置缓存行为：

| 模式 | 描述 |
|------|-------------|
| **Shared** | 启用缓存，响应可能会在用户之间共享（个人账户默认设置） |
| **Isolated** | 启用缓存，但响应对您的组织私有（组织默认设置） |
| **Disabled** | 完全不进行缓存 |

其他可用设置：
- **相似度阈值**：调整语义匹配灵敏度（默认：92%）
- **自定义 TTL**：覆盖缓存过期时间
- **排除的模型**：禁用特定模型的缓存

### 请求级别

使用 `cache_control` 参数进行按请求覆盖：

```bash
# 禁用此请求的缓存
curl https://api.lemondata.cc/v1/chat/completions \
  -H "Authorization: Bearer sk-your-key" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "gpt-4o",
    "messages": [{"role": "user", "content": "..."}],
    "cache_control": {"type": "no_store"}
  }'
```

## 缓存反馈

如果您收到错误的缓存响应，可以进行报告：

```bash
curl -X POST https://api.lemondata.cc/v1/cache/feedback \
  -H "Authorization: Bearer sk-your-key" \
  -H "Content-Type: application/json" \
  -d '{
    "cache_entry_id": "abc123",
    "feedback_type": "wrong_answer",
    "description": "Response was outdated"
  }'
```

**反馈类型：**
- `wrong_answer` - 事实错误
- `outdated` - 信息陈旧
- `irrelevant` - 与问题不匹配
- `other` - 其他问题

当缓存条目收到足够的负面反馈时，它会自动失效。

## 最佳实践

<AccordionGroup>
  <Accordion title="对可缓存的查询使用 temperature=0">
    确定性设置可最大化缓存命中率。
  </Accordion>

  <Accordion title="标准化 Prompt 格式">
    一致的格式可以提高语义匹配效果。
  </Accordion>

  <Accordion title="对时效性查询使用 no-cache">
    时事、实时数据应跳过缓存。
  </Accordion>

  <Accordion title="监控缓存命中率">
    在您的控制面板中查看缓存统计数据和节省情况。
  </Accordion>
</AccordionGroup>

## 何时不应缓存

为以下情况禁用缓存：

- **实时信息**：股票价格、天气、新闻
- **个性化内容**：针对特定用户的推荐
- **创意任务**：当需要多样性时
- **敏感数据**：机密信息

```python
# 对于时效性查询
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "What's the current stock price of AAPL?"}],
    extra_body={"cache_control": {"type": "no_cache"}}
)
```