---
title: "Gestion du cache"
description: "Contrôlez le comportement de mise en cache pour vos requêtes API"
---

## Présentation

LemonData gère automatiquement la mise en cache pour optimiser les performances et réduire les coûts. Bien qu'il n'existe pas de point de terminaison public pour vider les entrées du cache, vous avez un contrôle total sur le comportement de mise en cache via des contrôles au niveau de la requête.

## Contourner le cache

Pour obtenir des réponses fraîches sans utiliser le cache, utilisez le paramètre `cache_control` dans votre requête :

<CodeGroup>

```bash cURL
curl -X POST "https://api.lemondata.cc/v1/chat/completions" \
  -H "Authorization: Bearer sk-your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "gpt-4o",
    "messages": [{"role": "user", "content": "Hello!"}],
    "cache_control": {"type": "no_cache"}
  }'
```

```python Python
from openai import OpenAI

client = OpenAI(
    api_key="sk-your-api-key",
    base_url="https://api.lemondata.cc/v1"
)

response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": "Hello!"}],
    extra_body={"cache_control": {"type": "no_cache"}}
)

print(response.choices[0].message.content)
```

```javascript JavaScript
const response = await fetch(
  'https://api.lemondata.cc/v1/chat/completions',
  {
    method: 'POST',
    headers: {
      'Authorization': 'Bearer sk-your-api-key',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: 'Hello!' }],
      cache_control: { type: 'no_cache' }
    })
  }
);

const data = await response.json();
console.log(data);
```

</CodeGroup>

## Options de contrôle du cache

| Type | Effet |
|------|--------|
| `no_cache` | Ignorer la recherche dans le cache, toujours obtenir une réponse fraîche |
| `no_store` | Ne pas stocker cette réponse dans le cache |
| `response_only` | Utiliser uniquement le cache de correspondance exacte (ignorer le sémantique) |
| `semantic_only` | Utiliser uniquement le cache sémantique (ignorer la correspondance exacte) |

## Retours sur le cache

Si vous recevez une réponse mise en cache incorrecte, vous pouvez la signaler :

```bash
curl -X POST "https://api.lemondata.cc/v1/cache/feedback" \
  -H "Authorization: Bearer sk-your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "cache_entry_id": "abc123",
    "feedback_type": "wrong_answer",
    "description": "Response was outdated"
  }'
```

Lorsqu'une entrée de cache reçoit suffisamment de retours négatifs, elle est automatiquement invalidée.

## Cas d'utilisation

<AccordionGroup>
  <Accordion title="Tester des réponses fraîches">
    Pendant le développement, utilisez `cache_control: {"type": "no_cache"}` pour vous assurer d'obtenir des réponses API fraîches.
  </Accordion>

  <Accordion title="Requêtes sensibles au facteur temps">
    Pour les données en temps réel comme les cours de la bourse ou la météo, utilisez toujours `no_cache` pour obtenir des informations à jour.
  </Accordion>

  <Accordion title="Débogage">
    Lors du débogage de réponses inattendues, utilisez `no_cache` pour exclure les résultats mis en cache.
  </Accordion>
</AccordionGroup>

<Note>
  Pour plus de détails sur la mise en cache, consultez le [Guide de mise en cache](/guides/caching).
</Note>