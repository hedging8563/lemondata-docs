---
title: "✨ 다중 형식 API"
description: "단 하나의 API key로 OpenAI, Anthropic 또는 Gemini 형식을 사용할 수 있습니다"
---

## 개요

LemonData는 단일 API key를 통해 **세 가지 네이티브 API 형식**을 지원합니다. 구성을 변경할 필요 없이 사용 사례에 가장 적합한 형식을 선택하세요.

<CardGroup cols={3}>
  <Card title="OpenAI 형식" icon="plug">
    `/v1/chat/completions`
    표준 형식, 가장 광범위한 호환성
  </Card>
  <Card title="Anthropic 형식" icon="message">
    `/v1/messages`
    확장 사고, 네이티브 Claude 기능
  </Card>
  <Card title="Gemini 형식" icon="sparkles">
    `/v1beta/models/:model:generateContent`
    Google 에코시스템 통합
  </Card>
</CardGroup>

## 왜 다중 형식을 사용하나요?

| 장점 | 설명 |
|---------|-------------|
| **SDK 전환 불필요** | 선호하는 SDK를 사용하여 모든 모델을 호출할 수 있습니다 |
| **네이티브 기능** | 특정 형식 전용 기능에 액세스 |
| **쉬운 마이그레이션** | base URL만 변경하여 공식 API에서 전환 가능 |
| **통합 결제** | 하나의 계정, 하나의 API key로 모든 형식 지원 |

## 형식 비교

| 기능 | OpenAI | Anthropic | Gemini |
|---------|--------|-----------|--------|
| **Endpoint** | `/v1/chat/completions` | `/v1/messages` | `/v1beta/models/:model:generateContent` |
| **인증 헤더** | `Authorization: Bearer` | `x-api-key` | `Authorization: Bearer` |
| **System Prompt** | messages 배열 내 | 독립된 `system` 필드 | `systemInstruction` 내 |
| **확장 사고** | ❌ | ✅ | ❌ |
| **스트리밍 (Streaming)** | ✅ SSE | ✅ SSE | ✅ SSE |
| **도구 호출** | ✅ | ✅ | ✅ |
| **비전 (Vision)** | ✅ | ✅ | ✅ |

## OpenAI 형식

가장 광범위한 호환성을 제공하는 형식입니다. 모든 LemonData 모델에 적용 가능합니다.

```python
from openai import OpenAI

client = OpenAI(
    api_key="sk-your-lemondata-key",
    base_url="https://api.lemondata.cc/v1"
)

# 모든 모델에 적용 가능
response = client.chat.completions.create(
    model="claude-sonnet-4-5",  # OpenAI 형식을 통해 Claude 호출
    messages=[
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": "Hello!"}
    ]
)
```

**가장 적합한 경우:**
- 일반적인 용도
- 기존 OpenAI SDK 통합
- 최대 호환성

## Anthropic 형식

네이티브 Anthropic Messages API입니다. Claude 전용 기능(예: 확장 사고)을 사용할 때 필수적입니다.

```python
from anthropic import Anthropic

client = Anthropic(
    api_key="sk-your-lemondata-key",
    base_url="https://api.lemondata.cc"  # /v1 접미사 불필요!
)

message = client.messages.create(
    model="claude-sonnet-4-5",
    max_tokens=1024,
    system="You are a helpful assistant.",  # 독립된 system 필드
    messages=[
        {"role": "user", "content": "Hello!"}
    ]
)
```

### 확장 사고 (Claude Opus 4.5)

Anthropic 형식에서만 제공됩니다:

```python
message = client.messages.create(
    model="claude-opus-4-5",
    max_tokens=16000,
    thinking={
        "type": "enabled",
        "budget_tokens": 10000
    },
    messages=[{"role": "user", "content": "Solve this complex problem..."}]
)

# 사고 과정 액세스
for block in message.content:
    if block.type == "thinking":
        print(f"Thinking: {block.thinking}")
    elif block.type == "text":
        print(f"Answer: {block.text}")
```

**가장 적합한 경우:**
- Claude 전용 기능
- 확장 사고 모드
- 네이티브 Anthropic SDK 사용자

## Gemini 형식

Google 에코시스템 통합을 위한 네이티브 Google Gemini API 형식입니다.

```bash
curl "https://api.lemondata.cc/v1beta/models/gemini-2.5-flash:generateContent" \
  -H "Authorization: Bearer sk-your-lemondata-key" \
  -H "Content-Type: application/json" \
  -d '{
    "contents": [{
      "parts": [{"text": "Hello!"}]
    }],
    "systemInstruction": {
      "parts": [{"text": "You are a helpful assistant."}]
    }
  }'
```

### 스트리밍 (Streaming)

```bash
curl "https://api.lemondata.cc/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse" \
  -H "Authorization: Bearer sk-your-lemondata-key" \
  -H "Content-Type: application/json" \
  -d '{
    "contents": [{"parts": [{"text": "Write a story"}]}]
  }'
```

**가장 적합한 경우:**
- Google Cloud 통합
- 기존 Gemini SDK 코드
- 네이티브 Gemini 기능

## 올바른 형식 선택하기

```mermaid
graph TD
    A[어떤 형식을 선택해야 할까요?] --> B{Claude 확장 사고가 필요한가요?}
    B -->|예| C[Anthropic 형식 사용]
    B -->|아니요| D{기존 코드베이스?}
    D -->|OpenAI SDK| E[OpenAI 형식 사용]
    D -->|Anthropic SDK| C
    D -->|Gemini SDK| F[Gemini 형식 사용]
    D -->|새 프로젝트| E
```

## 마이그레이션 가이드

### 공식 OpenAI API에서 마이그레이션

```python
# 마이그레이션 전 (OpenAI)
client = OpenAI(api_key="sk-openai-key")

# 마이그레이션 후 (LemonData)
client = OpenAI(
    api_key="sk-lemondata-key",
    base_url="https://api.lemondata.cc/v1"  # 이 줄 추가
)
# 이것으로 끝입니다! 동일한 코드로 작동합니다
```

### 공식 Anthropic API에서 마이그레이션

```python
# 마이그레이션 전 (Anthropic)
client = Anthropic(api_key="sk-ant-key")

# 마이그레이션 후 (LemonData)
client = Anthropic(
    api_key="sk-lemondata-key",
    base_url="https://api.lemondata.cc"  # 이 줄 추가 (/v1 불필요!)
)
```

### Google AI Studio에서 마이그레이션

```python
# 마이그레이션 전 (Google)
import google.generativeai as genai
genai.configure(api_key="google-api-key")

# 마이그레이션 후 (LemonData) - REST API 사용
import requests

response = requests.post(
    "https://api.lemondata.cc/v1beta/models/gemini-2.5-flash:generateContent",
    headers={"Authorization": "Bearer sk-lemondata-key"},
    json={"contents": [{"parts": [{"text": "Hello"}]}]}
)
```

## 모델 간 호환성

LemonData의 마법: **어떤 SDK**든 **어떤 모델**과 함께 사용하세요. 게이트웨이가 형식 변환을 자동으로 처리합니다.

### 모든 SDK → 모든 모델

```python
# Anthropic SDK를 사용하여 GPT-4o 호출 (OpenAI 형식으로 자동 변환)
from anthropic import Anthropic

client = Anthropic(
    api_key="sk-lemondata-key",
    base_url="https://api.lemondata.cc"
)

response = client.messages.create(
    model="gpt-4o",  # ✅ 정상 작동! 자동 변환됨
    max_tokens=1024,
    messages=[{"role": "user", "content": "Hello!"}]
)

# 동일한 SDK, 다른 모델 — 코드 변경 불필요
response = client.messages.create(model="gemini-2.5-flash", ...)  # ✅ 정상 작동!
response = client.messages.create(model="deepseek-r1", ...)       # ✅ 정상 작동!
```

### OpenAI SDK → 모든 모델

```python
from openai import OpenAI

client = OpenAI(base_url="https://api.lemondata.cc/v1", api_key="sk-...")

# 다음 모델들은 모두 동일한 SDK로 작동합니다:
response = client.chat.completions.create(model="gpt-4o", ...)
response = client.chat.completions.create(model="claude-sonnet-4-5", ...)
response = client.chat.completions.create(model="gemini-2.5-flash", ...)
```

### 업계 비교

| 플랫폼 | OpenAI 형식 | Anthropic 형식 | Gemini 형식 | Responses API |
|----------|:---:|:---:|:---:|:---:|
| **LemonData** | ✅ 모든 모델 | ✅ 모든 모델 | ✅ 모든 모델 | ✅ 모든 모델 |
| OpenRouter | ✅ 모든 모델 | ❌ | ❌ | ❌ |
| Together AI | ✅ 모든 모델 | ❌ | ❌ | ❌ |
| Fireworks | ✅ 모든 모델 | ❌ | ❌ | ❌ |

<Note>
다중 형식 지원은 대부분의 기능을 지원하지만, 특정 형식 전용 기능(예: Anthropic 확장 사고)은 여전히 네이티브 형식을 사용해야 합니다.
</Note>