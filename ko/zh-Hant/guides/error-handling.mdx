---
title: "오류 처리"
description: "API 오류를 유연하게 처리하기"
---

## 오류 응답 형식

모든 오류는 일관된 JSON 형식으로 반환됩니다:

```json
{
  "error": {
    "message": "Human-readable error description",
    "type": "error_type",
    "code": "error_code",
    "param": "parameter_name"  // 選填，用於驗證錯誤
  }
}
```

## HTTP 상태 코드

| 코드 | 설명 |
|------|-------------|
| 400 | Bad Request - 파라미터가 유효하지 않음 |
| 401 | Unauthorized - API key가 유효하지 않거나 누락됨 |
| 402 | Payment Required - 잔액 부족 |
| 403 | Forbidden - 액세스가 거부되었거나 해당 모델 사용이 허용되지 않음 |
| 404 | Not Found - 모델 또는 리소스를 찾을 수 없음 |
| 413 | Payload Too Large - 입력 또는 파일 크기가 제한을 초과함 |
| 429 | Too Many Requests - 속도 제한 초과 |
| 500 | Internal Server Error - 서버 내부 오류 |
| 502 | Bad Gateway - 업스트림 공급업체 오류 |
| 503 | Service Unavailable - 모든 채널 실패 |
| 504 | Gateway Timeout - 요청 시간 초과 |

## 오류 유형

### 인증 오류 (401)

| 유형 | 코드 | 설명 |
|------|------|-------------|
| `invalid_api_key` | `invalid_api_key` | API key가 누락되었거나 유효하지 않음 |
| `expired_api_key` | `expired_api_key` | API key가 취소됨 |

```python
from openai import OpenAI, AuthenticationError

try:
    response = client.chat.completions.create(...)
except AuthenticationError as e:
    print(f"Authentication failed: {e.message}")
```

### 결제 오류 (402)

| 유형 | 코드 | 설명 |
|------|------|-------------|
| `insufficient_quota` | `insufficient_quota` | 계정 잔액이 너무 낮음 |
| `quota_exceeded` | `quota_exceeded` | API key 사용 제한에 도달함 |

```python
from openai import OpenAI, APIStatusError

try:
    response = client.chat.completions.create(...)
except APIStatusError as e:
    if e.status_code == 402:
        print("Please top up your account balance")
```

### 액세스 오류 (403)

| 유형 | 코드 | 설명 |
|------|------|-------------|
| `access_denied` | `access_denied` | 리소스 액세스가 거부됨 |
| `access_denied` | `model_not_allowed` | 이 API key로는 해당 모델을 사용할 수 없음 |

```json
{
  "error": {
    "message": "You don't have permission to access this model",
    "type": "access_denied",
    "code": "model_not_allowed"
  }
}
```

### 검증 오류 (400)

| 유형 | 설명 |
|------|-------------|
| `invalid_request_error` | 요청 파라미터가 유효하지 않음 |
| `context_length_exceeded` | 입력 내용이 모델에 비해 너무 김 |
| `model_not_found` | 요청한 모델이 존재하지 않음 |

```json
{
  "error": {
    "message": "model: 'invalid-model' is not a valid model",
    "type": "model_not_found",
    "param": "model"
  }
}
```

### 속도 제한 오류 (429)

속도 제한을 초과한 경우:

```json
{
  "error": {
    "message": "Rate limit exceeded. Please slow down.",
    "type": "rate_limit_error",
    "code": "rate_limit_exceeded"
  }
}
```

**포함된 헤더 (Headers):**

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1234567890
Retry-After: 60
```

### 페이로드 크기 초과 (413)

입력 또는 파일 크기가 제한을 초과한 경우:

```json
{
  "error": {
    "message": "Input size exceeds maximum allowed",
    "type": "invalid_request_error",
    "code": "payload_too_large"
  }
}
```

일반적인 원인:
- 이미지 파일 크기 초과 (최대 20MB)
- 오디오 파일 크기 초과 (최대 25MB)
- 입력 텍스트가 모델의 컨텍스트 길이(context length)를 초과함

### 업스트림 오류 (502, 503)

| 유형 | 설명 |
|------|-------------|
| `upstream_error` | 공급업체 응답 오류 |
| `all_channels_failed` | 사용 가능한 공급업체 없음 |
| `timeout_error` | 요청 시간 초과 |

## Python에서 오류 처리하기

```python
from openai import OpenAI, APIError, RateLimitError, APIConnectionError

client = OpenAI(
    api_key="sk-your-api-key",
    base_url="https://api.lemondata.cc/v1"
)

def chat_with_retry(messages, max_retries=3):
    for attempt in range(max_retries):
        try:
            return client.chat.completions.create(
                model="gpt-4o",
                messages=messages
            )
        except RateLimitError as e:
            if attempt < max_retries - 1:
                import time
                time.sleep(2 ** attempt)  # Exponential backoff
                continue
            raise
        except APIConnectionError as e:
            print(f"Connection error: {e}")
            raise
        except APIError as e:
            print(f"API error: {e.status_code} - {e.message}")
            raise
```

## JavaScript에서 오류 처리하기

```javascript
import OpenAI from 'openai';

const client = new OpenAI({
  apiKey: 'sk-your-api-key',
  baseURL: 'https://api.lemondata.cc/v1'
});

async function chatWithRetry(messages, maxRetries = 3) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await client.chat.completions.create({
        model: 'gpt-4o',
        messages
      });
    } catch (error) {
      if (error instanceof OpenAI.RateLimitError) {
        if (attempt < maxRetries - 1) {
          await new Promise(r => setTimeout(r, 2 ** attempt * 1000));
          continue;
        }
      }
      throw error;
    }
  }
}
```

## 모범 사례

<AccordionGroup>
  <Accordion title="지수 백오프(Exponential Backoff) 구현">
    속도 제한이 발생했을 때 재시도 사이의 대기 시간을 점진적으로 늘립니다:
    ```python
    wait_time = 2 ** attempt  # 1s, 2s, 4s, 8s...
    ```
  </Accordion>

  <Accordion title="타임아웃(Timeouts) 설정">
    요청이 중단되는 것을 방지하기 위해 합리적인 타임아웃 시간을 설정하십시오:
    ```python
    client = OpenAI(timeout=60.0)  # 60 秒逾時
    ```
  </Accordion>

  <Accordion title="디버깅을 위한 오류 로깅">
    지원을 요청할 수 있도록 전체 오류 응답(request ID 포함)을 기록하십시오:
    ```python
    except APIError as e:
        logger.error(f"API Error: {e.status_code} - {e.message}")
    ```
  </Accordion>

  <Accordion title="특정 모델 관련 오류 처리">
    일부 모델에는 특정 요구 사항(예: 최대 token 수, 이미지 형식)이 있습니다.
    요청을 보내기 전에 입력을 검증하십시오.
  </Accordion>
</AccordionGroup>